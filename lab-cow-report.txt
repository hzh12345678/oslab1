cow实验报告

本实验要实现copy-on-write功能，fork()时，
子进程不申请新的物理内存，而是将子进程的页表映射到父进程的物理内存，
同时将这段物理内存设置为不可写。当任一进程试图写入其中一个物理页时，
CPU将强制产生页面错误，会使得usertrap中r_scause为15。
然后usertrap对cow导致的page fault进行特殊的处理，
为其分配新的页面即可。

在riscv.h中添加PTE_RSW位，用来标志cow页面。

首先，修改uvmcopy()，复制时将父进程的页映射到子进程，而不是分配新页。在子进程和父进程的PTE中清除PTE_W标志，标志PTE_RSW位。

利用一个数组来计数每个页面的cow数量，用kalloc分配时初始化对应计数器为1,每次有子进程复制出来就把计数加1,
每次kfree如果还有至少两个cow页面则计数器减1，如果没有了就正常释放内存。这里要注意用一个锁处理多进程可能导致的冲突。

然后修改usertrap()，当cow页面出现page fault时，根据标志位确定是否是cow情况，如果是，尝试使用kalloc()分配一个新页面，
并将旧页面复制到新页面，将旧的页面空间释放掉，然后将新页面添加到PTE中并设置PTE_W，PTE_RSW位。

最后修改copyout，在遇到cow页面时使用与页面错误相同的处理方法，如果是cow，
就分配新的内存给页面，然后继续copyout。

我遇到过的问题有：在usertrap函数中，出现问题之后，比如地址大于最大地址，让进程setkill之后，
应该直接exit，否则他会继续运行usertrap函数，导致出错，修改后问题解决。