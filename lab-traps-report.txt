Oslab2实验报告
实验1：backtrace
backtrace实验要求在printf.c文件中实现一个backtrace函数，它的作用是在调用后输出当前的栈的函数返回地址，只需要从r_fp指针位置开始，依次输出在fp-8位置的地址，跳转到fp-16位置，直到跳出当前的page即可。
实验2：alarm
Test0:在这个环节，我按照提示，配置好Makefile，完成sigalarm和sigreturn函数声明，在对应的位置加上用于调用函数的代码，此时sigreturn直接return 0，然后再proc结构中加上3个结构，一个是一个整数，表示alarm_interval，即alarm的时间限制，一个是函数指针alarm_handler，用于指向处理trap的函数，一个是ticks_since_last_alarm，用于表示距离上次alarm的ticks数。它们在proc的构造函数中分别初始化为0，在sigalarm函数中，得到proc的interval和handler的具体值，赋给对应的变量，并将ticks置为0。然后修改trap.c中的usertrap函数，每次timer interrupt，令ticks加1，如果发现ticks等于interval，修改trapframe中储存的要跳转的函数为handler函数，这样程序就会在之后跳转到handler函数，然后再把ticks重置为0即可。
Test123：先要求了代码能够恢复中断前的状态，这意味着我们需要储存alarm之前所有的寄存器数据，只需要复制一份trapframe之后再正常执行alarm处理，sigreturn退出之后再把副本存回trapframe即可，这需要在proc结构中多加一个trapframe结构体，在构造和析构函数中，仿照trapframe的alloc和free分别对新的结构做同样的操作。然后要求防止重复执行handler函数，只需要在proc中多加一个变量in_alarm表示是否执行了handler函数，在usertrap中，当ticks等于interval时，如果in_alarm是1，则不会再重复执行handler函数，在sigreturn函数中，handler函数执行完毕，将in_alarm置为0，说明没有在执行handler函数，之后在alarm就会正常进入alarm_handler。最后为了确保储存并恢复了a0，把sigreturn的返回值设成a0即可。